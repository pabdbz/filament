<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ASCII Ange (mobile friendly)</title>
  <style>
    body {
      margin:0;
      background:#000;
      color:#eee;
      font-family:monospace;
      overflow:hidden;
      touch-action: none; /* empêche le scroll / zoom pendant le mouvement */
    }
    #ascii {
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      white-space:pre;
      text-align:center;
      font-size:16px;
      line-height:0.7;
      user-select:none;
    }
    @media (max-width:600px) {
      #ascii {
        font-size:12px;
        line-height:0.8;
      }
    }
  </style>
</head>
<body>
  <pre id="ascii">Chargement…</pre>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
  const asciiEl = document.getElementById("ascii");
  const chars = "@#W$9876543210?!abc;:+=-,._ ";

  const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  // Ne pas l’ajouter explicitement, c’est un rendu caché

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.z = 10;

  const light = new THREE.DirectionalLight(0xffffff,1);
  light.position.set(1,1,1);
  scene.add(light);

  const mat = new THREE.MeshStandardMaterial({ color:0xffffff });

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,3,32), mat);
  scene.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.7,32,16), mat);
  head.position.y = 2.2;
  scene.add(head);
  const wingLeft = new THREE.Mesh(new THREE.ConeGeometry(1.5,3,16), mat);
  wingLeft.position.set(-1.8,1,0);
  wingLeft.rotation.z = Math.PI/2.5;
  scene.add(wingLeft);
  const wingRight = new THREE.Mesh(new THREE.ConeGeometry(1.5,3,16), mat);
  wingRight.position.set(1.8,1,0);
  wingRight.rotation.z = -Math.PI/2.5;
  scene.add(wingRight);
  const halo = new THREE.Mesh(new THREE.TorusGeometry(1,0.1,16,100), mat);
  halo.position.y = 3.3;
  halo.rotation.x = Math.PI/2;
  scene.add(halo);

  const cvs = document.createElement("canvas");
  const ctx = cvs.getContext("2d", { willReadFrequently: true });

  let targetX = 0, targetY = 0;
  let rx = 0, ry = 0;

  function handlePointer(x, y) {
    // x, y entre 0..window.innerWidth / innerHeight
    targetY = (x - window.innerWidth/2) * 0.002;
    targetX = (y - window.innerHeight/2) * 0.002;
  }

  // souris
  window.addEventListener("mousemove", e => {
    handlePointer(e.clientX, e.clientY);
  });

  // touch / pointer pour mobile
  window.addEventListener("touchmove", e => {
    e.preventDefault();
    if (e.touches && e.touches.length > 0) {
      const t = e.touches[0];
      handlePointer(t.clientX, t.clientY);
    }
  }, { passive: false });

  window.addEventListener("pointermove", e => {
    handlePointer(e.clientX, e.clientY);
  });

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  function renderAscii() {
    // adapter cols/rows pour mobile / desktop
    const isMobile = window.innerWidth < 600;
    const cols = Math.floor(window.innerWidth / (isMobile ? 16 : 12));
    const rows = Math.floor(window.innerHeight / (isMobile ? 24 : 18));

    cvs.width = cols;
    cvs.height = rows;
    ctx.drawImage(renderer.domElement, 0,0, cols, rows);
    const data = ctx.getImageData(0,0,cols,rows).data;

    let out = "";
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const i = (y * cols + x)*4;
        const lum = (0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2]) / 255;
        const idx = Math.floor((1 - lum) * (chars.length - 1));
        out += chars[idx];
      }
      out += "\n";
    }
    asciiEl.textContent = out;
  }

  function animate() {
    rx += (targetX - rx) * 0.05;
    ry += (targetY - ry) * 0.05;
    scene.rotation.x = rx;
    scene.rotation.y = ry * 0.8 + performance.now() * 0.0005;

    renderer.render(scene, camera);
    renderAscii();
    requestAnimationFrame(animate);
  }

  animate();
  </script>
</body>
</html>


