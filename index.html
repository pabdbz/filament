<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ASCII Ange — mobile friendly fix</title>
  <style>
    body {
      margin:0;
      background:#000;
      color:#eee;
      font-family:monospace;
      overflow:hidden;
      touch-action: none; /* empêche le scroll / zoom pendant l'interaction */
    }
    #ascii {
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      white-space:pre;
      text-align:center;
      user-select:none;
      margin:0;
      padding:0;
    }
  </style>
</head>
<body>
  <pre id="ascii">Chargement…</pre>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
  // ---------- config ----------
  const AUTO_ROTATE_ENABLED = true;         // si false : plus aucune auto-rotation (même au repos)
  const idleDelay = 3000;                  // ms d'inactivité avant que l'auto-rotate démarre (si AUTO_ROTATE_ENABLED==true)
  const mobileFontFactor = 0.55;           // réduction du facteur de taille sur mobile (ajuste si tu veux)
  const desktopFontFactor = 0.70;          // facteur sur desktop
  const colsDivisorDesktop = 12;           // plus petit -> plus de colonnes -> plus fin
  const rowsDivisorDesktop = 18;
  const colsDivisorMobile = 20;            // augmentation -> moins de colonnes sur mobile
  const rowsDivisorMobile = 28;

  // ---------- init ----------
  const asciiEl = document.getElementById("ascii");
  const chars = "@#W$9876543210?!abc;:+=-,._ ";

  const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer:true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.z = 10;

  const light = new THREE.DirectionalLight(0xffffff,1);
  light.position.set(1,1,1);
  scene.add(light);

  const mat = new THREE.MeshStandardMaterial({ color:0xffffff });

  // modèle simple (ton ange)
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,3,32), mat);
  scene.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.7,32,16), mat);
  head.position.y = 2.2;
  scene.add(head);
  const wingLeft = new THREE.Mesh(new THREE.ConeGeometry(1.5,3,16), mat);
  wingLeft.position.set(-1.8,1,0);
  wingLeft.rotation.z = Math.PI/2.5;
  scene.add(wingLeft);
  const wingRight = new THREE.Mesh(new THREE.ConeGeometry(1.5,3,16), mat);
  wingRight.position.set(1.8,1,0);
  wingRight.rotation.z = -Math.PI/2.5;
  scene.add(wingRight);
  const halo = new THREE.Mesh(new THREE.TorusGeometry(1,0.1,16,100), mat);
  halo.position.y = 3.3;
  halo.rotation.x = Math.PI/2;
  scene.add(halo);

  // offscreen canvas for sampling
  const cvs = document.createElement("canvas");
  const ctx = cvs.getContext("2d", { willReadFrequently: true });

  // rotation targets & smoothing
  let targetX = 0, targetY = 0;
  let rx = 0, ry = 0;

  // interaction / idle detection
  let lastInteraction = Date.now();

  function recordInteraction() {
    lastInteraction = Date.now();
  }

  function handlePointer(x, y) {
    // centre-based mapping
    const cx = x - window.innerWidth/2;
    const cy = y - window.innerHeight/2;
    targetY = cx * 0.002; // horizontal -> yaw-ish
    targetX = cy * 0.002; // vertical -> pitch-ish
    recordInteraction();
  }

  // mouse
  window.addEventListener('mousemove', e => handlePointer(e.clientX, e.clientY), { passive:true });

  // pointer events (unifie mouse/touch)
  window.addEventListener('pointermove', e => {
    if (e.pointerType === 'touch' || e.pointerType === 'mouse') handlePointer(e.clientX, e.clientY);
  }, { passive:true });

  // touch fallback (some phones)
  window.addEventListener('touchmove', e => {
    e.preventDefault(); // keep control of the gesture
    if (e.touches && e.touches[0]) handlePointer(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive:false });

  // resize handler
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // --------- rendering / ascii ----------
  function renderAscii() {
    const isMobile = window.innerWidth <= 720;

    const cols = Math.max(24, Math.floor(window.innerWidth / (isMobile ? colsDivisorMobile : colsDivisorDesktop)));
    const rows = Math.max(12, Math.floor(window.innerHeight / (isMobile ? rowsDivisorMobile : rowsDivisorDesktop)));

    cvs.width = cols;
    cvs.height = rows;

    // draw WebGL render to offscreen and sample it small
    ctx.drawImage(renderer.domElement, 0, 0, cols, rows);
    const img = ctx.getImageData(0,0,cols,rows).data;

    let out = '';
    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const i = (y*cols + x) * 4;
        const lum = (0.299*img[i] + 0.587*img[i+1] + 0.114*img[i+2]) / 255;
        const idx = Math.floor((1 - lum) * (chars.length - 1));
        out += chars[idx];
      }
      out += '\n';
    }
    asciiEl.textContent = out;

    // adaptive font-size: width / cols * factor -> clamp
    const baseFactor = isMobile ? mobileFontFactor : desktopFontFactor;
    let fontPx = Math.max(6, Math.floor(window.innerWidth / cols * baseFactor));
    fontPx = Math.min(28, fontPx); // clamp max
    asciiEl.style.fontSize = fontPx + 'px';
    // adjust line-height so lines don't overlap on mobile
    asciiEl.style.lineHeight = (isMobile ? 0.85 : 0.7);
  }

  // ---------- animation loop ----------
  function animate() {
    requestAnimationFrame(animate);

    // smoothing toward target
    rx += (targetX - rx) * 0.06;
    ry += (targetY - ry) * 0.06;

    // apply rotations to scene (or group if you prefer)
    scene.rotation.x = rx;
    scene.rotation.y = ry;

    // auto-rotate only when idle and configured
    if (AUTO_ROTATE_ENABLED) {
      const idle = (Date.now() - lastInteraction) > idleDelay;
      if (idle) {
        // gentle auto rotate when idle
        scene.rotation.y += 0.0006;
      }
    }

    renderer.render(scene, camera);
    renderAscii();
  }

  // kick off
  animate();

  // optional: expose toggles for debugging in console
  window.__asciiControls = {
    setAutoRotateEnabled(v){ /* call: __asciiControls.setAutoRotateEnabled(false) */
      // not implemented setter to keep simple; edit constant above if needed
      console.warn('Change AUTO_ROTATE_ENABLED in code to toggle auto-rotate.');
    }
  };

  </script>
</body>
</html>
